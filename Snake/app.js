// Generated by CoffeeScript 1.4.0
(function() {
  var Board, DELAY, Game, SIZE, Snake, board, browser, game, printBoard, runLoop, snake;

  Snake = function() {
    var snake;
    return snake = {
      mark: 'X',
      direction: 'east',
      positions: [[1, 1]],
      head: function() {
        return this.positions[this.positions.length - 1];
      },
      length: function() {
        return this.positions.length;
      },
      turn: function(direction) {
        return this.direction = direction;
      },
      nextPosition: function() {
        switch (this.direction) {
          case 'east':
            return [this.head()[0], this.head()[1] + 1];
          case 'west':
            return [this.head()[0], this.head()[1] - 1];
          case 'north':
            return [this.head()[0] - 1, this.head()[1]];
          case 'south':
            return [this.head()[0] + 1, this.head()[1]];
        }
      },
      onPosition: function(position) {
        var i, onPosition, _i, _ref;
        onPosition = false;
        for (i = _i = 0, _ref = this.positions.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.positions[i][0] === position[0] && this.positions[i][1] === position[1]) {
            onPosition = true;
          }
        }
        return onPosition;
      }
    };
  };

  Game = function(snake, board) {
    var game;
    return game = {
      board: board,
      snake: snake,
      mouse: {
        mark: '*',
        position: []
      },
      initialize: function() {
        board.initialize();
        board.setSnake(snake);
        return board.setMouse(this.mouse);
      },
      addToHead: function() {
        var next;
        snake.positions.push(next = snake.nextPosition());
        return board.markBoard(next, snake.mark);
      },
      takeFromTail: function() {
        var tail;
        tail = snake.positions.shift();
        return board.markBoard(tail, null);
      },
      checkCollisions: function() {
        var next;
        next = snake.nextPosition();
        return board.offBoard(next) || snake.onPosition(next);
      },
      checkMice: function() {
        var next;
        next = snake.nextPosition();
        return next[0] === this.mouse.position[0] && next[1] === this.mouse.position[1];
      },
      turn: function(direction) {
        return snake.turn(direction);
      },
      step: function() {
        if (this.checkCollisions()) {
          return false;
        }
        if (this.checkMice()) {
          this.addToHead();
          board.setMouse(this.mouse);
          return true;
        } else {
          this.addToHead();
          this.takeFromTail();
          return true;
        }
      }
    };
  };

  Board = function(size) {
    var board;
    return board = {
      initialize: function() {
        return this.setBoard();
      },
      board: [],
      size: size,
      setBoard: function() {
        var i, j, _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.board[i] = [];
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(this.markBoard([i, j], null));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      },
      setSnake: function(snake) {
        var i, _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = snake.positions.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.markBoard(snake.positions[i], snake.mark));
        }
        return _results;
      },
      setMouse: function(mouse) {
        var position;
        while (true) {
          position = this.randomPosition();
          if (!snake.onPosition(position)) {
            break;
          }
        }
        this.markBoard(position, mouse.mark);
        return mouse.position = position;
      },
      markBoard: function(position, mark) {
        return this.board[position[0]][position[1]] = mark;
      },
      randomPosition: function() {
        return [Math.floor(Math.random() * this.size), Math.floor(Math.random() * this.size)];
      },
      offBoard: function(position) {
        var x, y;
        x = position[0] > (this.size - 1) || position[0] < 0;
        y = position[1] > (this.size - 1) || position[1] < 0;
        return x || y;
      }
    };
  };

  printBoard = function(board) {
    var i, j, row, size, _i, _j, _results;
    size = board.length;
    _results = [];
    for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
      row = '';
      for (j = _j = 0; 0 <= size ? _j < size : _j > size; j = 0 <= size ? ++_j : --_j) {
        if (board[i][j] === null) {
          row += 'O';
        } else {
          row += board[i][j];
        }
      }
      _results.push(browser.println(row));
    }
    return _results;
  };

  browser = {
    println: function(string) {
      $('.output').append(string);
      return $('.output').append("\n");
    },
    clear: function() {
      return $('.output').html("");
    }
  };

  $('html').keydown(function(event) {
    switch (event.keyCode) {
      case 38:
        return snake.turn('north');
      case 40:
        return snake.turn('south');
      case 37:
        return snake.turn('west');
      case 39:
        return snake.turn('east');
    }
  });

  runLoop = function() {
    return window.setInterval((function() {
      var alive;
      browser.clear();
      alive = game.step();
      printBoard(board.board);
      if (!alive) {
        browser.println("You Lose!");
        return clearInterval(runLoop);
      }
    }), DELAY);
  };

  SIZE = parseInt(prompt("How large would you like the board?"));

  DELAY = 250;

  window.setTimeout(runLoop, DELAY);

  snake = Snake();

  board = Board(SIZE);

  game = Game(snake, board);

  game.initialize();

}).call(this);
